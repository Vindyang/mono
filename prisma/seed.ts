import { PrismaClient } from "../generated/prisma/client/index.js";
import { PrismaPg } from "@prisma/adapter-pg";
import { Pool } from "pg";
import dayjs from "dayjs";

const connectionString = process.env.DATABASE_URL;

const pool = new Pool({ connectionString });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

async function main() {
  console.log("ðŸŒ± Starting database seeding...");

  // Users data
  // We keep "key" for internal mapping, but don't insert it into DB.
  // userId (Int) will be generated by DB.
  const usersData = [
    {
      key: "user_1",
      name: "Alex Johnson",
      email: "alex.j@example.com",
      image: "https://i.pravatar.cc/150?u=1",
    },
    {
      key: "user_2",
      name: "Sarah Williams",
      email: "sarah.w@example.com",
      image: "https://i.pravatar.cc/150?u=2",
    },
    {
      key: "user_3",
      name: "Michael Chen",
      email: "michael.c@example.com",
      image: "https://i.pravatar.cc/150?u=3",
    },
    {
      key: "user_4",
      name: "Emily Davis",
      email: "emily.d@example.com",
      image: "https://i.pravatar.cc/150?u=4",
    },
    {
      key: "user_5",
      name: "David Wilson",
      email: "david.w@example.com",
      image: "https://i.pravatar.cc/150?u=5",
    },
  ];

  // Map to store userKey ("user_1") -> Real UUID
  const userKeyMap: Record<string, string> = {};

  for (const data of usersData) {
    // We strictly use Create or Update.
    // Since we changed schema, we assume we want to sync data.
    const user = await prisma.user.upsert({
      where: { email: data.email },
      update: {
        name: data.name,
        image: data.image,
      },
      create: {
        name: data.name,
        email: data.email,
        emailVerified: false,
        image: data.image,
      },
    });
    userKeyMap[data.key] = user.id;
  }
  console.log(`âœ… Seeded ${usersData.length} users`);

  // Workspace
  const workspaceData = {
    name: "Default Workspace",
    slug: "default",
    description: "Your default workspace for task management",
  };

  const workspace = await prisma.workspace.upsert({
    where: { slug: workspaceData.slug },
    update: {},
    create: workspaceData,
  });
  console.log(`âœ… Seeded workspace (ID: ${workspace.id})`);

  // Workspace Members
  const membersData = [
    {
      userKey: "user_1",
      role: "OWNER" as const,
      status: "ACTIVE" as const,
      joinedAt: new Date("2023-01-15"),
    },
    {
      userKey: "user_2",
      role: "ADMIN" as const,
      status: "ACTIVE" as const,
      joinedAt: new Date("2023-02-10"),
    },
    {
      userKey: "user_3",
      role: "MEMBER" as const,
      status: "OFFLINE" as const,
      joinedAt: new Date("2023-03-22"),
    },
    {
      userKey: "user_4",
      role: "MEMBER" as const,
      status: "BUSY" as const,
      joinedAt: new Date("2023-04-05"),
    },
    {
      userKey: "user_5",
      role: "VIEWER" as const,
      status: "ACTIVE" as const,
      joinedAt: new Date("2023-05-18"),
    },
  ];

  // Map user UUID to WorkspaceMember ID (Int)
  const userUuidToWorkspaceMemberId: Record<string, number> = {};

  for (const m of membersData) {
    const userId = userKeyMap[m.userKey];
    const wm = await prisma.workspaceMember.upsert({
      where: {
        workspaceId_userId: {
          workspaceId: workspace.id,
          userId: userId,
        },
      },
      update: {
        role: m.role,
        status: m.status,
      },
      create: {
        workspaceId: workspace.id,
        userId: userId,
        role: m.role,
        status: m.status,
        joinedAt: m.joinedAt,
      },
    });
    userUuidToWorkspaceMemberId[userId] = wm.id;
  }
  console.log(`âœ… Seeded ${membersData.length} workspace members`);

  // Invitations
  const invitationsData = [
    {
      email: "jessica.lee@example.com",
      role: "MEMBER" as const,
      status: "PENDING" as const,
      invitedByUserKey: "user_1",
      invitedAt: dayjs().subtract(2, "day").toDate(),
      expiresAt: dayjs().add(5, "day").toDate(),
    },
    {
      email: "robert.brown@example.com",
      role: "VIEWER" as const,
      status: "PENDING" as const,
      invitedByUserKey: "user_2",
      invitedAt: dayjs().subtract(5, "hour").toDate(),
      expiresAt: dayjs().add(7, "day").toDate(),
    },
  ];

  for (const inv of invitationsData) {
    await prisma.invitation.upsert({
      where: {
        workspaceId_email: {
          workspaceId: workspace.id,
          email: inv.email,
        },
      },
      update: {
        status: inv.status,
        expiresAt: inv.expiresAt,
      },
      create: {
        workspaceId: workspace.id,
        email: inv.email,
        role: inv.role,
        status: inv.status,
        invitedById: userKeyMap[inv.invitedByUserKey],
        invitedAt: inv.invitedAt,
        expiresAt: inv.expiresAt,
      },
    });
  }
  console.log(`âœ… Seeded ${invitationsData.length} invitations`);

  // Projects
  const projectsData = [
    {
      key: "proj_web",
      name: "Website Redesign",
      description: "Complete overhaul of the corporate website including new branding and improved UX.",
      color: "#3b82f6",
      dueDate: dayjs().add(2, "week").toDate(),
      status: "ACTIVE" as const,
    },
    {
      key: "proj_app",
      name: "Mobile App Launch",
      description: "Development and launch of the new iOS and Android mobile applications.",
      color: "#8b5cf6",
      dueDate: dayjs().add(1, "month").toDate(),
      status: "ACTIVE" as const,
    },
    {
      key: "proj_mkt",
      name: "Q4 Marketing Campaign",
      description: "Strategic marketing campaign for Q4 including social media, email, and ads.",
      color: "#10b981",
      dueDate: dayjs().add(3, "week").toDate(),
      status: "ACTIVE" as const,
    },
  ];

  const projectKeyToId: Record<string, number> = {};

  for (const p of projectsData) {
    const existing = await prisma.project.findFirst({
        where: { workspaceId: workspace.id, name: p.name }
    });

    let projectId: number;
    if (existing) {
        projectId = existing.id;
        await prisma.project.update({
            where: { id: projectId },
            data: {
                description: p.description,
                color: p.color,
                dueDate: p.dueDate,
                status: p.status,
            }
        });
    } else {
        const created = await prisma.project.create({
            data: {
                workspaceId: workspace.id,
                name: p.name,
                description: p.description,
                color: p.color,
                dueDate: p.dueDate,
                status: p.status,
            }
        });
        projectId = created.id;
    }
    projectKeyToId[p.key] = projectId;
  }
  console.log(`âœ… Seeded ${projectsData.length} projects`);

  // Project Members
  const projectMembersData = [
    { projKey: "proj_web", userKey: "user_1", role: "LEAD" as const },
    { projKey: "proj_web", userKey: "user_2", role: "MEMBER" as const },
    { projKey: "proj_web", userKey: "user_3", role: "MEMBER" as const },
    { projKey: "proj_app", userKey: "user_1", role: "LEAD" as const },
    { projKey: "proj_app", userKey: "user_4", role: "MEMBER" as const },
    { projKey: "proj_mkt", userKey: "user_2", role: "LEAD" as const },
    { projKey: "proj_mkt", userKey: "user_5", role: "VIEWER" as const },
  ];

  for (const pm of projectMembersData) {
    const projectId = projectKeyToId[pm.projKey];
    const userUuid = userKeyMap[pm.userKey];
    const workspaceMemberId = userUuidToWorkspaceMemberId[userUuid];

    if (!workspaceMemberId) continue;

    await prisma.projectMember.upsert({
      where: {
        projectId_workspaceMemberId: {
          projectId,
          workspaceMemberId,
        },
      },
      update: { role: pm.role },
      create: {
        projectId,
        workspaceMemberId,
        role: pm.role,
      },
    });
  }
  console.log(`âœ… Seeded ${projectMembersData.length} project members`);

  // Tasks
  const tasksData = [
    {
        key: "task_1",
        projKey: "proj_web",
        createdByUserKey: "user_1",
        title: "Design System Audit",
        description: "Review current components and identify inconsistencies",
        status: "DONE" as const,
        priority: "HIGH" as const,
        dueDate: dayjs().toDate(),
    },
    {
        key: "task_1b",
        projKey: "proj_web",
        createdByUserKey: "user_1",
        title: "Update Color Palette",
        description: "Refine primary and secondary colors for better contrast",
        status: "TODO" as const,
        priority: "MEDIUM" as const,
        dueDate: dayjs().toDate(),
    },
    {
        key: "task_1c",
        projKey: "proj_web",
        createdByUserKey: "user_2",
        title: "Fix Navigation Bug",
        description: "Menu doesn't close on mobile click",
        status: "IN_PROGRESS" as const,
        priority: "HIGH" as const,
        dueDate: dayjs().toDate(),
    },
    {
        key: "task_1d",
        projKey: "proj_web",
        createdByUserKey: "user_3",
        title: "Optimize Images",
        description: "Compress hero images for faster load time",
        status: "TODO" as const,
        priority: "LOW" as const,
        dueDate: dayjs().toDate(),
    },
    {
        key: "task_2",
        projKey: "proj_web",
        createdByUserKey: "user_1",
        title: "Homepage Hero Section",
        description: "Design and implement the new hero section with 3D elements",
        status: "IN_PROGRESS" as const,
        priority: "HIGH" as const,
        dueDate: dayjs().add(1, "day").toDate(),
    },
    {
        key: "task_4",
        projKey: "proj_app",
        createdByUserKey: "user_4",
        title: "Push Notification Setup",
        description: "Configure Firebase Cloud Messaging for iOS and Android",
        status: "IN_PROGRESS" as const,
        priority: "HIGH" as const,
        dueDate: dayjs().toDate(),
    },
    {
        key: "task_7",
        projKey: "proj_mkt",
        createdByUserKey: "user_2",
        title: "Social Media Calendar",
        description: "Plan posts for Instagram, LinkedIn, and Twitter",
        status: "TODO" as const,
        priority: "MEDIUM" as const,
        dueDate: dayjs().add(3, "day").toDate(),
    },
  ];

  const taskKeyToId: Record<string, number> = {};

  for (const t of tasksData) {
      const projectId = projectKeyToId[t.projKey];
      const existing = await prisma.task.findFirst({
          where: { projectId, title: t.title }
      });

      let taskId: number;
      if (existing) {
          taskId = existing.id;
          await prisma.task.update({
              where: { id: taskId },
              data: {
                  description: t.description,
                  status: t.status,
                  priority: t.priority,
                  dueDate: t.dueDate,
              }
          });
      } else {
          const created = await prisma.task.create({
              data: {
                  projectId,
                  createdById: userKeyMap[t.createdByUserKey],
                  title: t.title,
                  description: t.description,
                  status: t.status,
                  priority: t.priority,
                  dueDate: t.dueDate,
              }
          });
          taskId = created.id;
      }
      taskKeyToId[t.key] = taskId;
  }
  console.log(`âœ… Seeded ${tasksData.length} tasks`);

  // Task Assignees
  const taskAssigneesData = [
    { taskKey: "task_1", userKey: "user_1" },
    { taskKey: "task_1b", userKey: "user_2" },
    { taskKey: "task_1c", userKey: "user_2" },
    { taskKey: "task_1d", userKey: "user_3" },
    { taskKey: "task_2", userKey: "user_1" },
    { taskKey: "task_4", userKey: "user_4" },
    { taskKey: "task_7", userKey: "user_2" },
  ];

  for (const ta of taskAssigneesData) {
      const taskId = taskKeyToId[ta.taskKey];
      const userId = userKeyMap[ta.userKey];

      await prisma.taskAssignee.upsert({
          where: {
              taskId_userId: { taskId, userId }
          },
          update: {},
          create: { taskId, userId }
      });
  }
  console.log(`âœ… Seeded ${taskAssigneesData.length} task assignees`);

  console.log("\nðŸŽ‰ Database seeding completed successfully!");
}

main()
  .catch((e) => {
    console.error("âŒ Error during seeding:");
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    await pool.end();
  });
